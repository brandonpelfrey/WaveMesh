<html>
<head>
	<title>Mesh Waves</title>
	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/numeric.min.js"></script>
	<script type="text/javascript" src="js/sparse.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <style type="text/css">
    body {
        overflow: hidden;
    };
    </style>
</head>
<body>

<script>

    var camera, scene, renderer, stats;
    var geometry, material, mesh, colorScale=1.0, faceAreas;

    var simContext;
    var laplacian, identity;

    new THREE.JSONLoader().load( "models/sphere2.js", function( geometry ) { 
        window.geometry = geometry;
        init();

        setInterval(function() {
            animate();
        }, 1000 / 60.0);
    } );

    function allFacesQuad() {
    	for(var i=0; i<geometry.faces; ++i)
    		if(!(geometry.faces[i] instanceof THREE.Face4))
    			return false;
    	return true;
    }

    function EdgeToFaceMap(N) {
    	this.store = {}; //  backing hash table. bad practice...
    	this.N = N; 

    	// Take two vertices
    	this.add = function(va, vb, face) {
    		// insure that va<vb
    		if(vb<va) {
    			var _tmp = va;
    			va = vb;
    			vb = _tmp;
    		}

    		var idx = va+'-'+vb;//(this.N * va) + vb;
    		var entry = {vi:va, vj:vb, face:face};

    		if(this.store[idx] === undefined) {
    			this.store[idx] = [entry];
    		} else {
    			this.store[idx].push(entry);
    		}
    	};
    }

    function circumcenter(A,B,C) {
        var a = (new THREE.Vector3).sub(A,C);
        var b = (new THREE.Vector3).sub(B,C);
        var acb = (new THREE.Vector3).cross(a,b);

        var num = b.clone().multiplyScalar(a.dot(a)).subSelf(a.clone().multiplyScalar(b.dot(b)));
        return C.clone().addSelf(num.crossSelf(acb).multiplyScalar(.5/(acb.dot(acb))));
    }

    function buildWaveOperators() {
    	var nFaces = geometry.faces.length, nVertices = geometry.vertices.length, i;

    	// Build the identity operator
		var identityBuilder = new SparseMatrix(nFaces, nFaces);
		for(i=0; i<nFaces; ++i) {
			identityBuilder.accumulate(i,i,1.0);
		}
		identity = identityBuilder.getNumeric();

        // Build face area array (assumed planar)
        faceAreas = new Array(nFaces);
        for(i=0;i<nFaces;++i) {
            var a = geometry.vertices[geometry.faces[i].a];
            var b = geometry.vertices[geometry.faces[i].b];
            var c = geometry.vertices[geometry.faces[i].c];
            var e0 = a.clone().subSelf(b);
            var e1 = a.clone().subSelf(c);
            faceAreas[i] = e0.crossSelf(e1).length() * .5;
        }

		// Build the Laplacian for this mesh

		// 1. Get a map of edge -> faces sharing this edge
		// This is bad style using an object as a hash map, but it's the only native thing we have (read: speed)
		var edgeMap = new EdgeToFaceMap(nVertices);
		var face;
		for(i=0; i<nFaces; ++i) {
			face = geometry.faces[i];
            if(face instanceof THREE.Face3) {
    			edgeMap.add(face.a, face.b, i);
    			edgeMap.add(face.b, face.c, i);
    			edgeMap.add(face.c, face.a, i);
            }
            else if(face instanceof THREE.Face4) {
                edgeMap.add(face.a, face.b, i);
                edgeMap.add(face.b, face.c, i);
                edgeMap.add(face.c, face.d, i);
                edgeMap.add(face.d, face.a, i);
            }
		}

		laplacian = new SparseMatrix(nFaces, nFaces);
		var L = laplacian, ea, eb, C, verts = geometry.vertices, faces = geometry.faces, r, midedge;
		for(edge in edgeMap.store) {
			if(!edgeMap.store.hasOwnProperty(edge)) {
				continue;
			}

            if(edgeMap.store[edge].length != 2) {
                // If this is a boundary edge, then there is no flux across.
                continue;
            }

			entry = edgeMap.store[edge][0];
            
			ei = verts[entry.vi].clone();
			ej = verts[entry.vj].clone();

			i = edgeMap.store[edge][0].face;
			j = edgeMap.store[edge][1].face;

			midedge = ei.addSelf(ej).multiplyScalar(.5);
			
            var ci = circumcenter(verts[faces[i].a], verts[faces[i].b], verts[faces[i].c]);
            var cj = circumcenter(verts[faces[j].a], verts[faces[j].b], verts[faces[j].c]);

			r = midedge.distanceTo(ci) + midedge.distanceTo(cj);
			r = ei.subSelf(ej).length() / r;

			L.accumulate(i,i,-r);
			L.accumulate(j,j,-r);
			L.accumulate(i,j, r);
			L.accumulate(j,i, r);
		}

		laplacian = laplacian.getNumeric();

        // Construct the solution state vectors
        simContext.solution = new SparseMatrix(nFaces, 1);
        simContext.oldSolution = new SparseMatrix(nFaces, 1);

        // Start a bump at one of the sites. Everything else 0
        for(i=0; i<nFaces; ++i) {
            var fc = faces[i].centroid.clone();
            var r = 2*Math.exp(-25*fc.distanceToSquared(new THREE.Vector3(1,0,0)));
            simContext.solution.set(i,0,r);
            simContext.oldSolution.set(i,0,r);
        }

        simContext.solution = simContext.solution.getNumeric();
        simContext.oldSolution = simContext.oldSolution.getNumeric();

        // Don't know of a sparse matrix-scalar multiplication in numericJS...
        for(i=0;i<identity[2].length;++i)
            identity[2][i] *= 2.0;

        for(i=0;i<laplacian[2].length;++i)
            laplacian[2][i] *= simContext.timeStepSize * simContext.timeStepSize * simContext.omega;

        simContext.M = numeric.ccsadd(laplacian, identity);
    }

    function simUpdate() {
        var nextState = numeric.ccsDot(simContext.M, simContext.solution);
        nextState = numeric.ccssub(nextState, simContext.oldSolution);
        simContext.oldSolution = simContext.solution;
        simContext.solution = nextState;
    }

    function init() {

        // three.js
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 100 );
        camera.position.z = 1.8;

        scene = new THREE.Scene();

        // geometry = new THREE.TorusKnotGeometry(200,20,400,32,3,-2);
        geometry.computeFaceNormals();
        geometry.dynamic = true;

        //material = new THREE.MeshBasicMaterial( { color: 0x222222, wireframe: false } );
        material = new THREE.MeshBasicMaterial({color:0xffffff});
        material.vertexColors = THREE.FaceColors;

        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );
        renderer = new THREE.WebGLRenderer();

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // Simulation 
        simContext = {
            timeStepSize: .5,
            omega: 1
        };
        buildWaveOperators();

        // GUI
        var gui = new dat.GUI();
        gui.add(camera.position, 'z', .1, 10);
        gui.add(mesh.rotation, 'y', 0.0, Math.PI*2);
        gui.add(simContext, 'timeStepSize', 0.01, 1.0).onFinishChange(buildWaveOperators);
        gui.add(simContext, 'omega', 0.0, 1.0).onFinishChange(buildWaveOperators);
        gui.add(window,'colorScale', 1.0, 20.0);

        // stats bar
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';
        document.body.appendChild( stats.domElement );
    }

    function animate() {
        //requestAnimationFrame( animate );
        stats.begin();

        // Update simulation
        simUpdate();
        
        // Fill in the new face colors
        full = numeric.ccsFull(simContext.solution);
        var col;
        for(var i=0; i<geometry.faces.length; ++i) {
            col = full[i];
            if(col === undefined) { col = 0.0; }
            else { col = full[i][0]; }

            col = col * colorScale ;/// faceAreas[i];
            col = col + .25;
            if(col<0.0) col = 0.0;
            if(col>1.0) col = 1.0;
            /*
            col = col | 0;
            col = (col<<16) | (col<<8) | col;
            if(i<3) {
                console.log(col);
            }
            */
            

            col = (col*255) & 0xff;
            col = col + (col<<8) + (col<<16);
            geometry.faces[i].color = new THREE.Color(col);
        }
        geometry.__dirtyColors = true;
        geometry.colorsNeedUpdate = true;

        renderer.render( scene, camera );

        stats.end();
        
    }

</script>

</body>
</html>